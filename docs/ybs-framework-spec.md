# YBS Framework Specification

## Overview

**YBS (Yelich Build System)** is a meta-framework that enables AI agents to build complete software systems **autonomously** from specifications and step-by-step instructions.

**Core Philosophy:**
> Specifications are the single source of truth. Code is derived from specs, not the other way around.

**Key Innovation:** Zero-interruption autonomous AI development through configuration-first design, explicit verification, and mandatory code-to-spec traceability.

---

## Problems YBS Solves

### 1. Autonomous Execution Without Interruption
- Traditional: AI interrupts mid-build with questions
- YBS: Collects ALL decisions upfront in Step 0, enabling Steps 1-N to execute fully autonomously

### 2. Code-Spec Synchronization
- Traditional: Code written first, docs written later, docs drift out of sync
- YBS: Specs are primary; code implements specs; specs stay current through change management

### 3. Reproducible and Portable Builds
- Same specs + same steps = identical output every time
- Rebuild in any language/platform by pointing AI at same specs
- No "works on my machine" problems

---

## Core Concepts

| Concept | Meaning | Why It Matters |
|---------|---------|----------------|
| **Spec-as-Source** | Specifications ARE the primary artifact | AI can regenerate code from specs at any time |
| **Configuration-First** | Step 0 collects ALL user decisions upfront | Steps 1-N run fully autonomously |
| **Traceability** | Every line of code references its specification | Know exactly WHY code exists |
| **Verification-Driven** | Explicit success criteria for every step | AI knows when step is truly complete |
| **Language-Agnostic** | Works for ANY programming language or domain | One framework rules them all |

---

## Three-Layer Architecture

### Layer A: Framework (Language/System Agnostic)

```
ybs/framework/
├── methodology/              # How to use YBS
│   ├── overview.md
│   ├── writing-specs.md
│   ├── writing-steps.md
│   ├── executing-builds.md
│   ├── feature-addition-protocol.md
│   └── change-management.md
├── templates/                # Reusable patterns
│   ├── spec-template.md
│   ├── step-template.md
│   ├── adr-template.md
│   └── build-config-template.json
├── tools/                    # Helper scripts
│   ├── list-specs.sh
│   ├── list-steps.sh
│   ├── deps.sh
│   └── check-traceability.sh
└── docs/                     # Framework documentation
    ├── glossary.md
    ├── step-format.md
    ├── config-markers.md
    └── dependencies.md
```

### Layer B: System Definitions (One Per System)

```
system-name/
├── README.md                    # System overview
├── CLAUDE.md                    # AI agent guide (system-specific)
├── specs/                       # WHAT to build (requirements)
│   ├── technical/               # Architecture, APIs
│   ├── architecture/            # Decisions, trade-offs
│   ├── business/                # Requirements, ROI
│   ├── functional/              # Features, workflows
│   ├── testing/                 # Test plans
│   ├── security/                # Security requirements (optional)
│   └── operations/              # Deployment, monitoring (optional)
├── steps/                       # HOW to build it (instructions)
│   ├── STEPS_ORDER.txt          # Execution order (CRITICAL)
│   ├── ybs-step_000000000000.md # Step 0: Build Configuration
│   ├── ybs-step_<guid>.md       # Step 1
│   ├── ybs-step_<guid>.md       # Step 2
│   └── ...                      # More steps
├── docs/                        # System-specific documentation
│   └── architecture.md
└── builds/                      # Active build workspaces
    ├── demo/
    ├── test5/
    └── production/
```

### Layer C: Active Builds (One Per Build Instance)

```
builds/BUILDNAME/
├── BUILD_CONFIG.json            # User configuration (from Step 0)
├── BUILD_STATUS.md              # Progress tracking
├── SESSION.md                   # Crash recovery state (if interrupted)
├── [source code]                # Actual implementation
├── [tests]                      # Test files
├── [artifacts]                  # Build outputs
└── docs/
    └── build-history/           # Step completion records
        ├── ybs-step_000000000000-DONE.txt
        └── ybs-step_<guid>-DONE.txt
```

---

## Key Data Structures

### BUILD_CONFIG.json

**Purpose:** Store all configuration decisions from Step 0

**Structure:**
```json
{
  "version": "0.1.0",
  "generated": "2026-01-17T05:30:00Z",
  "system_name": "calculator",
  "values": {
    "system_name": "calculator",
    "language": "Python",
    "platform": "all",
    "enable_tests": true,
    "max_threads": 4
  },
  "metadata": {
    "total_steps": 11,
    "config_sources": ["ybs-step_000000000000"]
  }
}
```

**Key Properties:**
- Generated by Step 0, read by Steps 1-N
- If exists when Step 0 runs → skip questions, use existing config
- Machine-updatable for CI/CD automation
- Enables zero-interaction rebuilds

### BUILD_STATUS.md

**Purpose:** Human-readable progress tracking

**Contains:**
- Current step number and GUID
- Progress metrics (completed, in-progress, blocked)
- Test coverage and traceability metrics
- Issues encountered
- Next step GUID

### SESSION.md

**Purpose:** Crash recovery - track state for resumption

**Contains:**
- System name, build name, current step
- Timestamps (start, last update)
- Detailed progress breakdown
- Next actions
- Context notes

**Lifecycle:**
1. Created at session start (or loaded if exists)
2. Updated after every significant action
3. On completion: Moved to build-history

### Step File Format

**File Naming:** `ybs-step_<12-hex-guid>.md`
**Special:** Step 0 always uses `ybs-step_000000000000.md`

**Structure:**
```markdown
# Step NNNNNN: [Descriptive Title]

**Version**: 0.1.0

## Overview
[What and why, 1-2 paragraphs]

## Step Objectives
1. [Specific goal 1]
2. [Specific goal 2]

## Prerequisites
- Previous step: ybs-step_[guid]
- BUILD_CONFIG.json must exist

## Configurable Values
- `{{CONFIG:key_name|type|description|default}}`
- `{{CONFIG:language|choice[Python,JavaScript]|Programming language|Python}}`

## Traceability
**Implements**: spec-file.md § X.Y (Feature Name)
**References**: D04 (Decision name)

## Instructions
### 1. [Sub-step title]
[Detailed instructions]

**Commands**:
```bash
[command examples]
```

### 2. [Next sub-step]
...

## Verification
**This step is complete when**:
- [ ] File exists at path
- [ ] Code compiles: `npm build` succeeds
- [ ] Tests pass: `npm test` returns 0
- [ ] Verification command output matches expected

**Verification Commands**:
```bash
[commands to verify success]
```

**Expected Output:**
[what success looks like]

**Retry Policy:**
- Maximum 3 attempts
- If 3 failures: STOP and report
```

### CONFIG Markers

**Syntax:** `{{CONFIG:key|type|description|default}}`

**Available Types:**
- `string` - Free text
- `integer`, `float` - Numbers
- `boolean` - True/false
- `choice[opt1,opt2,...]` - Single selection
- `multichoice[opt1,opt2,...]` - Multiple selections
- `color`, `url`, `email`, `path` - Specialized types

**Example:**
```markdown
- `{{CONFIG:language|choice[Swift,Python,Go]|Programming language|Swift}}`
- `{{CONFIG:max_retries|integer|Maximum retry attempts|3}}`
- `{{CONFIG:enable_logging|boolean|Enable debug logging|true}}`
```

**Processing:**
1. Step 0 scans all steps for CONFIG markers
2. Generates questions based on markers
3. Saves answers to BUILD_CONFIG.json
4. Steps 1-N replace `{{CONFIG:key}}` with values from config

---

## Build Execution Protocol

### State Machine

```
START
  ↓
[Check for SESSION.md]
  ├→ Found: RESUME from saved state
  └→ Not found: FRESH START
  ↓
STEP 0 (Configuration Collection)
  ├→ BUILD_CONFIG.json exists: Load config, skip questions → Step 1
  └→ Doesn't exist: Ask questions, create BUILD_CONFIG.json → Step 1
  ↓
STEP 1-N (Sequential Execution)
  ↓
For each step:
  1. Read step file completely
  2. Replace {{CONFIG:key}} with values from BUILD_CONFIG.json
  3. Execute instructions step-by-step
  4. Create test files (if code implementation step)
  5. Run verification
     ├→ PASS: Mark complete, proceed to next step
     ├→ FAIL: Retry (up to 3 attempts)
     └→ 3 failures: STOP and report error
  6. Document completion (create step-DONE file)
  7. Update BUILD_STATUS.md
  8. PROCEED AUTOMATICALLY to next step (no user prompts)
  ↓
All steps complete
  ↓
BUILD COMPLETE
```

### Step 0: Configuration Collection

**Purpose:** Collect ALL configuration decisions upfront

**Logic:**
```
IF BUILD_CONFIG.json exists at builds/BUILDNAME/BUILD_CONFIG.json THEN
  READ and display config
  SKIP to Step 1
ELSE
  SCAN steps/ for {{CONFIG:...}} markers
  FOR EACH marker:
    PROMPT user for value
    VALIDATE input
  END FOR
  WRITE BUILD_CONFIG.json with all values
  PROCEED to Step 1
END
```

**Key Points:**
- Step 0 MUST run first - no exceptions
- If config exists, zero questions asked
- Enables fully autonomous Steps 1-N
- Machine-updatable for CI/CD variants

### Step N: Build Execution

**Input:**
- Step file (ybs-step_<guid>.md)
- BUILD_CONFIG.json
- Previous step outputs

**Process:**
1. Read and parse step file
2. Extract {{CONFIG:key}} placeholders
3. Load BUILD_CONFIG.json
4. Replace placeholders with config values
5. Execute Instructions section
6. Run Verification section
7. Check results:
   - All criteria met? → Success, proceed
   - Criteria failed? → Retry (up to 3 attempts)
   - 3 failures? → STOP and report
8. Record completion in build-history

**Output:**
- Implemented code/features
- Test files
- Documentation
- Step-DONE file with timing
- Updated BUILD_STATUS.md

---

## Traceability System

### In Source Files

**Format:**
```swift
// Implements: calculator-spec.md § 2.1 (Core Operations)
// Purpose: Provide basic arithmetic operations
import Foundation

func add(_ a: Double, _ b: Double) -> Double {
    return a + b
}
```

**Requirements:**
- Every source file must reference its specification
- Format: `// Implements: <spec-file> § <section> (<feature-name>)`
- Optional: `// Purpose:` for additional context

### Verification

**Command:**
```bash
check-traceability.sh SYSTEM BUILD
```

**Thresholds:**
- ✅ PASS: ≥80% of source files have traceability comments
- ⚠️ WARN: 60-79% traced
- ✗ FAIL: <60% traced

**Why It Matters:**
- Instant code review: Know WHY every line exists
- Specification updates propagate to code
- No orphaned code (code without purpose)
- AI can regenerate code from specs

---

## Tools and Utilities

### check-traceability.sh

**Purpose:** Verify code-to-spec references

**Usage:**
```bash
check-traceability.sh system-name build-name
```

**Output:**
- Percentage of traced files
- List of untraced files
- Pass/Warn/Fail status

### list-specs.sh

**Purpose:** List all specifications for a system

**Usage:**
```bash
list-specs.sh system-name
```

**Output:**
- All spec files with size and title
- Organized by category

### list-steps.sh

**Purpose:** Show build steps in execution order

**Usage:**
```bash
list-steps.sh system-name [--verbose]
```

**Output:**
- Step number, GUID, title
- With --verbose: objectives and timing estimates

### deps.sh

**Purpose:** Show feature dependency tree

**Usage:**
```bash
deps.sh system-name step-guid
```

**Output:**
- Required specs
- Optional specs
- Conflicting specs
- Dependent features

---

## Complete Workflow Example

### Building a Calculator System

**System:** 02-calculator (reference example)

**What it builds:** CLI calculator with add, subtract, multiply, divide operations

**Structure:**
```
02-calculator/
├── specs/
│   └── calculator-spec.md           # Complete specification
├── steps/
│   ├── STEPS_ORDER.txt
│   ├── calc-step_000000000000.md    # Step 0: Configuration
│   ├── calc-step_478a8c4b0cef.md    # Step 1: Project setup
│   ├── calc-step_c5404152680d.md    # Step 2: Calculator module
│   ├── calc-step_89b9e6233da5.md    # Step 3: Parser module
│   ├── calc-step_a1b2c3d4e5f6.md    # Step 4: Formatter
│   ├── calc-step_b2c3d4e5f6a1.md    # Step 5: CLI interface
│   ├── calc-step_c3d4e5f6a1b2.md    # Step 6: Unit tests (calc)
│   ├── calc-step_d4e5f6a1b2c3.md    # Step 7: Unit tests (parser)
│   ├── calc-step_e5f6a1b2c3d4.md    # Step 8: Integration tests
│   ├── calc-step_f6a1b2c3d4e5.md    # Step 9: Documentation
│   └── calc-step_a2b3c4d5e6f7.md    # Step 10: Final verification
└── builds/
    └── demo/                         # Example build
```

**Execution Timeline:**
- **Total:** ~3 hours (175 minutes)
- Step 0: 5-10 minutes (configuration)
- Steps 1-5: 70 minutes (implementation)
- Steps 6-8: 55 minutes (testing)
- Steps 9-10: 35 minutes (documentation & verification)

**Outcomes:**
- ✅ Complete working calculator
- ✅ Comprehensive unit tests
- ✅ Integration tests
- ✅ Full documentation
- ✅ ≥80% code coverage
- ✅ ≥80% traceability
- ✅ All requirements verified

---

## YBS as Transport-Independent Framework

### Critical Insight for YX Integration

**YBS is COMPLETELY independent of how it's invoked or transported.**

**YBS Defines:**
- ✅ WHAT (specifications)
- ✅ HOW (build steps)
- ✅ WHY (traceability, decisions)

**YBS Does NOT Define:**
- ❌ Communication protocol
- ❌ Message format
- ❌ Network layer
- ❌ Transport mechanism

### Implication

YBS works with ANY transport:
- Direct file system access (current)
- HTTP/REST API calls
- **YX protocol (UDP/RPC)**
- SSH remote execution
- WebSocket streaming
- Message queues
- Any network protocol

### YX Implementation Strategy

When implementing YBS on top of YX:

1. **YBS layer stays exactly the same**
   - Specifications remain unchanged
   - Build steps remain unchanged
   - Verification logic remains unchanged

2. **YX layer is the transport**
   - Messages flow over UDP
   - RPC calls for requests/responses
   - Packet security via HMAC/AES-GCM

3. **Mapping layer connects them**
   - Converts YBS requests to YX RPC calls
   - Converts YX responses to YBS data structures
   - Handles errors and retries

**Example Flow:**
```
AI Agent (YBS client)
  ↓ [Request: "Read spec file calculator-spec.md"]
YX RPC Call: ybs.readFile(path="specs/calculator-spec.md")
  ↓ [YX UDP packet, HMAC, encryption]
YBS Server (file system access)
  ↓ [Read file, return content]
YX RPC Response: {content: "...file contents..."}
  ↓ [YX UDP packet, HMAC, encryption]
AI Agent receives content
  ↓ [Continue building]
```

---

## AI Agent Rules for YBS Execution

### Core Rules

1. **Execute Step 0 first** - Always, no exceptions
2. **Check for BUILD_CONFIG.json** - If exists, skip questions
3. **Read steps completely** - Understand full context before starting
4. **Replace CONFIG values** - Substitute all placeholders with config values
5. **Follow instructions exactly** - Don't improvise or skip steps
6. **Verify before proceeding** - Don't skip verification checks
7. **Retry failed steps** - Up to 3 attempts per step
8. **Proceed autonomously** - No "Ready for next step?" prompts
9. **Update status files** - Track progress in BUILD_STATUS.md and SESSION.md
10. **Document timing** - Record actual elapsed time in step-DONE files

### What Success Looks Like

**Completed Build:**
- All steps executed in order
- All verification criteria met
- All tests passing
- Code coverage ≥80%
- Traceability ≥80%
- BUILD_STATUS.md shows 100% complete
- No SESSION.md (deleted on completion)
- Complete system ready for use

---

## YBS Value Proposition

### What YBS Enables

✅ **Zero-interruption builds** - No questions after Step 0
✅ **Full autonomy** - AI builds complete systems without human intervention
✅ **Complete traceability** - Every line of code traced to specification
✅ **Reproducible builds** - Same specs + same steps = same output
✅ **Language-agnostic** - Works for any programming language
✅ **Platform-agnostic** - Works for any operating system
✅ **Domain-agnostic** - Works for any type of software
✅ **Crash recovery** - Resume from interruption
✅ **Parallel execution** - Multiple agents building different systems
✅ **Machine-updatable config** - CI/CD variants with zero human interaction

### Core Value Statement

> **Write specifications once. AI agents build complete systems from scratch, in any language, on any platform, infinitely, without human intervention, with full traceability and reproducibility.**

This is fundamentally different from:
- Traditional development (code-first, specs-later, manual work)
- Manual AI prompting (fragmented, no traceability, constant interruptions)
- Other specification-driven tools (incomplete, require interaction, no autonomy)

**YBS is the complete methodology for autonomous AI software development in 2026.**

---

## Summary

YBS is a meta-framework that transforms software development from a manual, code-first process into an **autonomous, specification-driven process** where AI agents build complete systems from human-written specifications.

**Key characteristics:**
- Configuration-first (Step 0 collects all decisions)
- Specification-driven (specs are source of truth)
- Verification-driven (explicit success criteria)
- Fully autonomous (zero interruptions after Step 0)
- Transport-independent (works with any communication layer)

**Perfect for YX integration** because YBS defines the "what" and "how" of building, while YX provides the secure, efficient "transport" for distributed YBS operations.
